# JWT

## 1. 什么是JWT?
- 通俗的讲，JWT 就是用一种结构化封装的方式来生成 token 的技术。
结构化后的 token 可以被赋予非常丰富的含义，这也是它与原先毫无意义的、随机的字符串形式 token 的最大区别。
- 官方定义，JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑的、自包含的方式，
用于作为 JSON 对象在各方之间安全地传输信息。

## 2. JWT的组成
- JWT 这种结构化体可以分为 HEADER（头部）、PAYLOAD（数据体）和 SIGNATURE（签名）三部分。
- 经过签名之后的 JWT 的整体结构，是被句点符号分割的三段内容，结构为 header.payload.SIGNATURE 三部分。
例如：
```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJVU0VSVEVTVCIsImV4cCI6MTU4NDEwNTc5MDcwMywiaWF0IjoxNTg0MTA1OTQ4MzcyfQ.1HbleXbvJ_2SW8ry30cXOBGR9FW4oSWBd3PWaWKsEXE
```
https://jwt.io/ jwt工具可反解：

```
HEADER:ALGORITHM & TOKEN TYPE

{
  "typ": "JWT",
  "alg": "HS256"
}

PAYLOAD:DATA

{
  "sub": "USERTEST",
  "exp": 1584105790703,
  "iat": 1584105948372
}

VERIFY SIGNATURE

HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)
```
- HEADER 表示装载令牌类型和算法等信息，是 JWT 的头部。其中，typ 表示第二部分 PAYLOAD 是 JWT 类型，
alg 表示使用 HS256 对称签名的算法。

- PAYLOAD 表示是 JWT 的数据体，代表了一组数据。
其中，sub（令牌的主体，一般设为资源拥有者的唯一标识）、exp（令牌的过期时间戳）、
iat（令牌颁发的时间戳）是 JWT 规范性的声明，代表的是常规性操作。
更多的通用声明，你可以参考RFC 7519 开放标准。
不过，在一个 JWT 内可以包含一切合法的 JSON 格式的数据，也就是说，PAYLOAD 表示的一组数据允许我们自定义声明。

- Signature 是 Token 的签名部分，通过如下方式生成：将 Header 和 Payload 分别 base64 编码后，用 . 连接。然后再使用 Header 中声明的加密方式，利用 secretKey 对连接后的字符串进行加密，加密后的字符串即为最终的 Signature。当受保护资源接收到第三方软件的签名后需要验证令牌的签名是否合法。

## 3. JWT优缺点

### 1) JWT优点
- 受保护资源来调用授权服务提供的检验令牌的服务，我们把这种校验令牌的方式称为令牌内检。
在有了 JWT 令牌之后，我们就多了一种选择，因为 JWT 令牌本身就包含了之前所要依赖数据库或者
依赖 RPC 服务才能拿到的信息，比如我上面提到的哪个用户为哪个软件进行了授权等信息。
授权服务“扔出”一个令牌，受保护资源服务“接住”这个令牌，然后自己开始解析令牌本身所包含的信息就可以了，
而不需要再去查询数据库或者请求 RPC 服务。

- JWT 令牌需要进行 Base64 编码以防止乱码，同时还需要进行签名及加密处理来防止数据信息泄露。
JWT 令牌内部已经包含了重要的信息，在整个传输过程中都必须被要求是密文传输的，
这样被强制要求了加密也就保障了传输过程中的安全性。

- JJWT（Java JWT）一个支持JWT的 JAVA类库，就不用我们再去处理编码、加密等工作，其底层已经封装好了。

- 使用 JWT 格式的令牌，有助于增强系统的可用性和可伸缩性。
这种 JWT 格式的令牌，通过“自编码”的方式包含了身份验证需要的信息，不再需要服务端进行额外的存储，所以每次的请求都是无状态会话。这就符合了我们尽可能遵循无状态架构设计的原则，也就是增强了系统的可用性和伸缩性。

### 2) JWT缺点：
JWT 格式令牌的最大问题在于 “覆水难收”，也就是说，没办法在使用过程中修改令牌状态。

小明在使用小兔软件的时候，是不是有可能因为某种原因修改了在京东的密码，或者是不是有可能突然取消了给小兔的授权？
这时候，令牌的状态是不是就要有相应的变更，将原来对应的令牌置为无效。
使用 JWT 格式令牌时，每次颁发的令牌都不会在服务端存储，这样我们要改变令牌状态的时候，就无能为力了。

为了解决这个问题，我们可以把 JWT 令牌存储到远程的分布式内存数据库中吗？
显然不能，因为这会违背 JWT 的初衷（将信息通过结构化的方式存入令牌本身）。

#### 正确的做法：
- 将每次生成 JWT 令牌时的秘钥粒度缩小到用户级别，也就是一个用户一个秘钥。
这样，当用户取消授权或者修改密码后，就可以让这个密钥一起修改。
一般情况下，这种方案需要配套一个单独的密钥管理服务。
JWT中唯有密钥信息会在服务端存储，且会做验证，因此只要改变密钥，使用旧密钥加密的JWT令牌即时失效。
- 在不提供用户主动取消授权的环境里面，如果只考虑到修改密码的情况，
那么我们就可以把用户密码作为 JWT 的密钥。
当然，这也是用户粒度级别的。这样一来，用户修改密码也就相当于修改了密钥。
建议第一种方式，毕竟密码是用户敏感信息，虽然加了密，但少用为好。

### 两点建议：
- 不要存放敏感信息在 Token 里；
- Payload 中的 exp 值不要设置得太大，一般开发版本 7 天，线上版本 2 小时。
当然，你也可以根据需要自行设置。


### JWT是否会丢失安全性？
JWT（JSON Web Token）的自包含性和无状态性确实减少了对服务器端存储会话信息的需求，例如不需要在Redis这样的外部存储中维护全局会话缓存。但这并不直接意味着安全性会有所牺牲，而是将安全的关注点转移到了其他方面。以下是几个与JWT安全性相关的要点：

1. **签名机制**：JWT通过签名来保证其内容的完整性和来源的真实性。使用HMAC（基于共享密钥的哈希消息认证码）或RSA、ECDSA等公钥/私钥对进行签名，确保了JWT在传输过程中不被篡改，并且可以验证JWT是由可信源发出的。只要签名密钥安全，JWT的内容就是安全的。

2. **过期时间**：JWT通常包含一个过期时间（exp claim），这限制了Token的有效期限，减少了被盗用后长时间有效的风险。开发者需要合理设置过期时间，以平衡用户体验和安全性。

3. **刷新Token**：为了进一步增强安全性，实践中常采用刷新Token机制。当JWT接近过期时，可以用刷新Token请求一个新的JWT，而不会暴露主要的访问凭证。刷新Token应具有更短的有效期，并且应更加谨慎地保管。

4. **密钥管理**：JWT的安全性高度依赖于密钥的安全管理。如果签名密钥泄露，攻击者就能伪造JWT。因此，定期轮换密钥、严格控制访问权限以及安全存储密钥至关重要。

5. **最小权限原则**：JWT中携带的信息应当遵循最小权限原则，仅包含完成操作所必需的最少用户信息，减少因Token泄露造成的损失。

综上所述，虽然JWT减少了对服务器端会话存储的依赖，但通过上述措施可以有效地维护其安全性。实际上，这种设计可以简化系统架构，提高可扩展性，同时通过正确的实施策略保持安全性。