1. 什么是JWT?
JWT 就是用一种结构化封装的方式来生成 token 的技术。
结构化后的 token 可以被赋予非常丰富的含义，这也是它与原先毫无意义的、随机的字符串形式 token 的最大区别。
官方定义：
JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑的、自包含的方式，
用于作为 JSON 对象在各方之间安全地传输信息。

2. JWT的组成
JWT 这种结构化体可以分为 HEADER（头部）、PAYLOAD（数据体）和 SIGNATURE（签名）三部分。
经过签名之后的 JWT 的整体结构，是被句点符号分割的三段内容，结构为 header.payload.SIGNATURE 三部分。
例如：
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJVU0VSVEVTVCIsImV4cCI6MTU4NDEwNTc5MDcwMywiaWF0IjoxNTg0MTA1OTQ4MzcyfQ.1HbleXbvJ_2SW8ry30cXOBGR9FW4oSWBd3PWaWKsEXE

https://jwt.io/ jwt工具可反解：
HEADER:ALGORITHM & TOKEN TYPE

{
  "typ": "JWT",
  "alg": "HS256"
}

PAYLOAD:DATA

{
  "sub": "USERTEST",
  "exp": 1584105790703,
  "iat": 1584105948372
}

VERIFY SIGNATURE

HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)

HEADER 表示装载令牌类型和算法等信息，是 JWT 的头部。其中，typ 表示第二部分 PAYLOAD 是 JWT 类型，
alg 表示使用 HS256 对称签名的算法。

PAYLOAD 表示是 JWT 的数据体，代表了一组数据。
其中，sub（令牌的主体，一般设为资源拥有者的唯一标识）、exp（令牌的过期时间戳）、
iat（令牌颁发的时间戳）是 JWT 规范性的声明，代表的是常规性操作。
更多的通用声明，你可以参考RFC 7519 开放标准。
不过，在一个 JWT 内可以包含一切合法的 JSON 格式的数据，也就是说，PAYLOAD 表示的一组数据允许我们自定义声明。

我们还需要对其进行加密签名处理，而 SIGNATURE 就是对信息的签名结果，
当受保护资源接收到第三方软件的签名后需要验证令牌的签名是否合法。

3. JWT的使用和优缺点
受保护资源来调用授权服务提供的检验令牌的服务，我们把这种校验令牌的方式称为令牌内检。

在有了 JWT 令牌之后，我们就多了一种选择，因为 JWT 令牌本身就包含了之前所要依赖数据库或者
依赖 RPC 服务才能拿到的信息，比如我上面提到的哪个用户为哪个软件进行了授权等信息。

授权服务“扔出”一个令牌，受保护资源服务“接住”这个令牌，然后自己开始解析令牌本身所包含的信息就可以了，
而不需要再去查询数据库或者请求 RPC 服务。

小兔软件拿着 JWT 令牌来请求受保护资源服务，也就是小明在京东店铺的订单。很显然，JWT 令牌需要在公网上做传输。
所以在传输过程中，JWT 令牌需要进行 Base64 编码以防止乱码，同时还需要进行签名及加密处理来防止数据信息泄露。

因为 JWT 令牌内部已经包含了重要的信息，所以在整个传输过程中都必须被要求是密文传输的，
这样被强制要求了加密也就保障了传输过程中的安全性。

JJWT（Java JWT）一个支持JWT的 JAVA类库，就不用我们再去处理编码、加密等工作，其底层已经封装好了。

另外，使用 JWT 格式的令牌，有助于增强系统的可用性和可伸缩性。这一点要怎么理解呢？
这种 JWT 格式的令牌，通过“自编码”的方式包含了身份验证需要的信息，不再需要服务端进行额外的存储，所以每次的请求都是无状态会话。
这就符合了我们尽可能遵循无状态架构设计的原则，也就是增强了系统的可用性和伸缩性。

但JWT也有缺点：
JWT 格式令牌的最大问题在于 “覆水难收”，也就是说，没办法在使用过程中修改令牌状态。

小明在使用小兔软件的时候，是不是有可能因为某种原因修改了在京东的密码，或者是不是有可能突然取消了给小兔的授权？
这时候，令牌的状态是不是就要有相应的变更，将原来对应的令牌置为无效。
使用 JWT 格式令牌时，每次颁发的令牌都不会在服务端存储，这样我们要改变令牌状态的时候，就无能为力了。

为了解决这个问题，我们可以把 JWT 令牌存储到远程的分布式内存数据库中吗？
显然不能，因为这会违背 JWT 的初衷（将信息通过结构化的方式存入令牌本身）。

正确的做法：
1）将每次生成 JWT 令牌时的秘钥粒度缩小到用户级别，也就是一个用户一个秘钥。
这样，当用户取消授权或者修改密码后，就可以让这个密钥一起修改。
一般情况下，这种方案需要配套一个单独的密钥管理服务。
JWT中唯有密钥信息会在服务端存储，且会做验证，因此只要改变密钥，使用旧密钥加密的JWT令牌即时失效。
2）在不提供用户主动取消授权的环境里面，如果只考虑到修改密码的情况，
那么我们就可以把用户密码作为 JWT 的密钥。
当然，这也是用户粒度级别的。这样一来，用户修改密码也就相当于修改了密钥。
建议第一种方式，毕竟密码是用户敏感信息，虽然加了密，但少用为好。